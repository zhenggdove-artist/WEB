    useFrame((rState, delta) => {
        const time = rState.clock.getElapsedTime();
        
        // --- ANIMATION STATE MACHINE ---
        switch (state) {
            case 'IDLE':
                breathStatus.current.isFiring = false;
                breathStatus.current.isMouthOpen = false;
                breathStatus.current.isRoaring = false;
                progress.current = 0;
                fadeRef.current = 0;
                fireHoldRef.current = 0;
                firePlanRef.current = false;
                if (time > nextTriggerTime.current) {
                    firePlanRef.current = Math.random() < BREATH_TIMING.fireProbability;
                    setState('PRE_FIRE');
                    timerRef.current = 0; // Reset local timer
                    fireTimerRef.current = 0;
                    fireHoldRef.current = 0;
                }
                break;

            case 'PRE_FIRE':
                breathStatus.current.isMouthOpen = true;
                breathStatus.current.isFiring = false;
                breathStatus.current.isRoaring = !firePlanRef.current;
                timerRef.current += delta;
                if (timerRef.current > BREATH_TIMING.preFireDelay) {
                    if (firePlanRef.current) {
                        setState('FIRING');
                        progress.current = 0.0;
                        fireHoldRef.current = 0;
                        fireTimerRef.current = 0;
                        fadeRef.current = 1;
                        breathStatus.current.isRoaring = false;
                    } else {
                        setState('ROAR');
                        timerRef.current = 0;
                    }
                }
                break;

            case 'ROAR':
                breathStatus.current.isMouthOpen = true;
                breathStatus.current.isFiring = false;
                breathStatus.current.isRoaring = true;
                timerRef.current += delta;
                if (timerRef.current > BREATH_TIMING.mouthHoldNoFire) {
                    setState('IDLE');
                    nextTriggerTime.current = time + BREATH_TIMING.idleDelayMin + Math.random() * BREATH_TIMING.idleDelayJitter;
                }
                break;

            case 'FIRING':
                breathStatus.current.isFiring = true;
                breathStatus.current.isMouthOpen = true;
                breathStatus.current.isRoaring = false;
                fireTimerRef.current += delta;
                progress.current += delta * BREATH_TIMING.fireGrowSpeed;
                if (progress.current >= 1.0) {
                    progress.current = 1.0;
                    fireHoldRef.current += delta;
                    if (fireHoldRef.current >= BREATH_TIMING.fireDuration || fireTimerRef.current >= 1.0) {
                        timerRef.current = 0;
                        setState('FADING');
                    }
                }
                if (fireTimerRef.current >= 1.0) {
                    fireHoldRef.current = 0;
                }
                break;

            case 'FADING':
                breathStatus.current.isFiring = true;
                breathStatus.current.isMouthOpen = true;
                breathStatus.current.isRoaring = false;
                progress.current = 1.0;
                timerRef.current += delta;
                fireTimerRef.current += delta;
                fadeRef.current = Math.max(0, 1 - timerRef.current * BREATH_TIMING.fadeSpeed);
                if (fireTimerRef.current >= 1.0 || fadeRef.current <= 0.01) {
                    breathStatus.current.isFiring = false;
                    breathStatus.current.isMouthOpen = false;
                    breathStatus.current.isRoaring = false;
                    fireHoldRef.current = 0;
                    fireTimerRef.current = 0;
                    setState('IDLE');
                    nextTriggerTime.current = time + BREATH_TIMING.idleDelayMin + Math.random() * BREATH_TIMING.idleDelayJitter;
                }
                break;
        }

        // Update Shader
        if (meshRef.current) {
            const mat = meshRef.current.material as THREE.ShaderMaterial;
            mat.uniforms.uTime.value += delta;
            const currentScale = state === 'FADING' ? 1 : progress.current;
            mat.uniforms.uFireScale.value = currentScale;
            mat.uniforms.uFade.value = fadeRef.current;
            const mouthAngle = breathStatus.current.mouthAngle || 0;
            meshRef.current.rotation.x = -mouthAngle;
            meshRef.current.visible = (state === 'FIRING' || state === 'FADING') && fadeRef.current > 0.01;
        }
    });
